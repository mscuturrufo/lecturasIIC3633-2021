## Matrix factorization techniques for recommender systems

El articulo por Koren, Bell y Volinksky (2009) inicia destacando la superioridad de *matrix factorization*, para modelos de factores latentes, por sobre técnicas de *nearest-neighbor*. Menciona que ambas áreas son parte de la estrategia *collaborative filtering* (CF), no obstante,  destaca que *neighborhood method* se centra básicamente en transformar a los *users* al espacio de los *items* y así verlos como "*baskets of rated items*" Por otro lado, los modelos de factores latentes transforman tanto *items* como *users* en el mismo espacio latente para hacerlos directamente comparables. En particular, *matrix factorization* se destaca por combinar buena escalabilidad con *predictive accuracy*, además de poder agregar información adicional como *implicit feedback*: historial de búsqueda, movimiento de puntero, tiempo en pantalla, entre otras. Finalmente, los autores describen el método SVD para el mapeo de interacciones *user-item* al espacio de factores latentes, los algoritmos de aprendizaje para trabajar solo con los ratings disponibles evitando *overfitting*, cómo añadir *biases* y la naturaleza dinámica del problema.

El articulo, tanto por sus figuras y estructura, es ordenado, fácil de leer e introduce eficazmente el método *matrix factorization*. No obstante, a lo largo de la lectura me surgieron algunas dudas que no logré resolver con la información expuesta en el articulo. Por ejemplo, en el apartado *Temporal Dynamics* se menciona que el sistema debe tener en cuenta los efectos temporales, pero solo se enfoca en cambios en la preferencia de los usuarios. No obstante, un problema importante por la naturaleza dinámica del sistema, que el articulo no menciona cómo resolver, es la incorporación de nuevos *users* o *items* al sistema. Lo que plantea el articulo es encontrar la matriz de ratings por medio de la descomposición SVD, por lo que, al agregar nuevos *users* o *items* se deberían recalcular las matrices encontradas por la factorización. Me imagino que esto no es trivial para bases de datos significativamente grandes, por lo que probablemente existan soluciones más sofisticadas que no se mencionan.

Bajo el contexto anterior, también me surgieron las siguientes preguntas con respecto a la separación de la base de datos en conjuntos training/validation/testing. ¿La factorización se debería hacer antes o después de la separación? También, según la naturaleza de CF, ¿se deben elegir *users* y *items* aleatorios o asociaciones (*users*, *items*) aleatorias? Creo que estas son decisiones que afectarían directamente a la *accuracy* y tiempo de ejecución de los sistemas, por lo que me imagino que no se dejan "a la suerte".

A modo de conclusión, creo que el articulo cumple con el objetivo de informar y explicar a grandes rasgos el recién aprendido modelo de factores latentes. Sin embargo, espero poder resolver las preguntas planteadas para que, en el futuro, pueda implementar el método de *matrix factorization* correctamente.
